---
title: "Genes associated with pCR"
output:
  html_document:
    df_print: paged
---

### Introduction

This experiment is a full differential expression analysis of breast cancer tumour samples to find genes that are associated with pCR to neoadjuvant chemotherapy (NAC). It uses samples obtained before NAC. the samples are annotated accordig to their pCR status.

The protocol is base on the execution of three R scripts that perform the following steps:
1. Load RCC files. Build counts matrix
2. Data normalisation
3. DE analysis

### Execution
#### Load the data
Get a matrix with the raw counts from the set of samples we want to analyse. In this case we select pre NAC samples and their correspondent RCC files to build an RCCSet and get the counts matrix

```{r echo=FALSE, message=FALSE, warning=FALSE}
# set seed to be reproduciblish
set.seed(12345)

# set working directory
source("dataloc.R") # This sets the working directory and defines the path to the RCC files in the variabla DataDir
rccDir <- file.path(DataDir, "RCCData")

source("../../bin/coreDEA_1.R")

pre_samples <- metadata %>% dplyr::filter(key1 == 0) ## Get only the samples PRE NAC for pCR DEA
eset <- getRCCSet(pre_samples)
counts <- getcountsfromRCC(pre_samples)

metadata <- pre_samples

```

We are working with `r nrow(metadata)` samples. We might not obtain significant results till we have the full set of samples (ca. 100 samples).


#### QC Control an normalisation.
Even though the samples we analyse here have passed the QC checks via nSolver. We monitor some QC aspects and normalise the data according to several criteria.

##### Imaging QC
Imaging QC refers to the percentage of fields of view (FOVs) successfully counted by a Digital Analyzer scan of a lane. When a substantial percentage of FOVs are not successfully counted, there may be issues with the resulting data (see nSolver User Manual). 

Our samples look fine in terms of the area imaged on each cartridge.
```{r echo=FALSE, message=F, warning=F}
source("../../bin/coreDEA_2.R")
plotFOV(eset = eset, metadata = metadata, fov_threshold = 80)
```

##### Binding density QC
Due to the nature of the nCounter technology, analysis of some samples may produce too many or too few probes to be accurately counted by the Digital Analyzer. When too many probes are present, the Digital Analyzer is not able to distinguish each and every probe present in the lane. When too few fluorescent species are present, the Digital Analyzer may have difficulty focusing on the lane surface. Therefore, a measurement of mean binding density (spots per square micron) is provided with each lane scanned. The linear range of counting extends from 0.05 to 2.25 spots per square micron for assays run on an nCounter MAX or FLEX system. The range is 0.05 to 1.18 spots per square micron for assays run on the nCounter SPRINT system.  (see nSolver User Manual).

```{r message=FALSE, warning=FALSE, echo=FALSE}
plotBD(eset = eset, metadata = metadata)
```


##### Positive Controls

Check the expression of the positive controls. The positive genes follow the expeted pattern of expresssion.
```{r echo=FALSE, message=FALSE, warning=FALSE}
boxplot_expr(eset,is_positive)
```


Check the expression of the negative controls
```{r message=FALSE, warning=FALSE}
boxplot_expr(eset,is_negative)
```

##### Noise Threshold

We establish a noise threshold. This threshold is based on the mean and standard deviation of counts of the negative control genes and represents the background noise. We define it as the mean expression of the negative genes counts + 2 times the standard deviation.
```{r echo=FALSE, comment=F, warning=F}
lodcounts = extract_pred(eset, is_negative)
lod = mean(lodcounts$count) + 2 * sd(lodcounts$count)
```

##### Housekeeping genes

Expression of each housekeeping genes in all samples. The line in red represents the noise threshold.

We can observe that all the housekeeping genes have enough expression (above the noise threshold).
```{r echo=FALSE}
X <- boxplot_expr(eset,is_housekeeping)
X + geom_hline(yintercept = (lod),colour="red")
```

##### Expression of all the housekeeping genes in each sample.

We plot the mean expression of all the housekeeping genes in each sample. We can obverve that some sample have overall low expression for the housekeeping genes, but all are above the noise threshold.



```{r echo=FALSE, message=F, warning=F}
counts = exprs(eset)
hk = counts[grepl("Housekeeping", rownames(counts)),]
hkDF<-as.data.frame(hk)
tidyHK<-tidyr::gather(hkDF)
colnames(tidyHK)<-c("sample","count")
ggplot(tidyHK, aes(sample, count)) + geom_boxplot(colour = "black", fill = "#CCCCCC",outlier.size = 0.5) +
     scale_y_continuous(trans = "log2") + 
     xlab("") + ggtitle("") + theme(axis.text.x = element_text(angle = 90, 
     hjust = 1,vjust = 0.5,size = 5))+
    geom_smooth(se=T, aes(group=1))+
    geom_hline(yintercept = (lod),colour="red")+
    ylab("counts")
```

##### General expression

Expression of all genes (Endogenous + Housekeeping).

```{r echo=FALSE, warning=F, message=F}
counts = exprs(eset)
endG = counts[grepl("Endogenous", rownames(counts)),]
hk = counts[grepl("Housekeeping", rownames(counts)),]
all<-rbind(endG,hk)
allDF<-as.data.frame(all)
tidyallDF <-tidyr::gather(allDF)
colnames(tidyallDF)<-c("sample","count")
ggplot(tidyallDF, aes(sample, count)) + geom_boxplot(colour = "black", fill = "#56B4E9",outlier.size = 0.5) +
     scale_y_continuous(trans = "log2") + 
     xlab("") + ggtitle("") + theme(axis.text.x = element_text(angle = 90, 
     hjust = 1,vjust = 0.5,size = 5))+
    geom_smooth(se=T, aes(group=1))+
    geom_hline(yintercept = lod,colour="red")
```


#### Normalisation
##### Positive Normalization

We perform a normalization using the expression of the positive genes. This attempts to normalize for technical noise across the samples
```{r echo=FALSE}
geo_pos = function(eset) {
     counts = exprs(eset)
     hk = counts[grepl("Positive", rownames(counts)), ]
     geoMeans = apply(hk, 2, function(col) exp(mean(log(col[col != 0]))))
     return(geoMeans)
 }
posFactor = function(eset) {
     geoMeans = geo_pos(eset)
     nf = mean(geoMeans)/geoMeans
     return(nf)
}
metadata$pos_nf = posFactor(eset)
counts = exprs(eset)

counts = counts[!grepl("Positive", rownames(counts)),]
counts = counts[!grepl("Negative", rownames(counts)),]

prenorm = counts %>% data.frame() %>% tidyr::gather("sample", "count")
prenorm$sample<-gsub("X","",prenorm$sample)
ggplot(prenorm, aes(sample, count)) + geom_boxplot(colour = "black", fill = "#56B4E9",outlier.size = 0.5) +
     scale_y_continuous(trans = "log2") + 
     xlab("") + ggtitle("pre-normalization") + theme(axis.text.x = element_text(angle = 90, 
     hjust = 1,vjust = 0.5,size = 5))+
    geom_hline(yintercept = lod,colour="red")
```


```{r echo=FALSE}
ncounts = counts %*% diag(metadata$pos_nf)
colnames(ncounts) = colnames(counts)
postnorm = ncounts %>%
  data.frame() %>%
  tidyr::gather("sample", "count")
postnorm$sample<-gsub("X","",postnorm$sample)
ggplot(postnorm, aes(sample, count)) +
  geom_boxplot(colour = "black", fill = "#56B4E9",outlier.size = 0.5) +
  scale_y_continuous(trans = "log2") +
  xlab("") + ggtitle("post-normalization") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1,vjust = 0.5,size = 5))+
    geom_hline(yintercept = lod,colour="red")
```

We can see that this normalisation doesn;t make the samples look better.


##### Housekeeping normalization

We select thouse housekeeping genes that have expression values greater than the noise threshold and a mean value of expression of at least 200 counts.

```{r echo=FALSE}
hk = ncounts[grepl("Housekeeping", rownames(ncounts)),]
abovenoise = rowSums(hk > (lod)) >= (ncol(hk))
hk_abovenoise = hk[abovenoise,]
aboveMean = (apply(hk_abovenoise,1,mean))>= 200
hk_sel= hk_abovenoise[aboveMean,]
hk_norm=rownames(hk_sel)
```

Out of the `r length(rownames(hk))` housekeeping genes, only `r length(rownames(hk_sel))` pass these criteria.

Using those genes, we observe that samples obtain more similar profiles.
```{r echo=FALSE, message= FALSE, warning= FALSE}
hk_pos = function(counts) {
  hk = counts[hk_norm,]
  geoMeans = apply(hk, 2, function(col) exp(mean(log(col[col != 0]))))
  return(geoMeans)}
hkFactor = function(counts) {
  geoMeans = hk_pos(counts)
  nf = mean(geoMeans) / geoMeans
  return(nf)}
metadata$hk_nf = hkFactor(ncounts)
ncounts = ncounts %*% diag(metadata$hk_nf)
colnames(ncounts) = colnames(counts)
postnorm = ncounts %>%
  data.frame() %>%
  tidyr::gather("sample", "count")
postnorm$sample<-gsub("X","",postnorm$sample)

ggplot(postnorm, aes(sample, count)) + geom_boxplot(colour = "black", fill = "#56B4E9",outlier.size = 0.5) +
     scale_y_continuous(trans = "log2") + 
     xlab("") + ggtitle("") + theme(axis.text.x = element_text(angle = 90, 
     hjust = 1,vjust = 0.5,size = 5))+
    geom_smooth(se=T, aes(group=1))+
    geom_hline(yintercept = lod,colour="red")
```


##### Drop genes and produce the normalised counts matrix
We’ll drop the genes that are below the LOD in over 80% of the samples:

```{r echo=FALSE}
allNames<-rownames(ncounts)
ncounts = ncounts[(rowSums(ncounts < lod) < round((0.2 * ncol(ncounts)),0)),]
filteredNames<-rownames(ncounts)
filterOutGenes<-allNames[allNames%!in%filteredNames]
```

We save the metadata dataframe and the normalised counts matrix for further analysis.
```{r echo=FALSE}
saveRDS(metadata, "preNAC_metadata.rds")
saveRDS(ncounts, "preNAC_HKnormalised_counts.rds")
```

##### PCA
A PCA (Principal Component Analysis) performs a transformation over the data in order to obtain orthogonal vectors in such a way that the first principal component has the largest possible variance (that is, accounts for as much of the variability in the data as possible), and each succeeding component in turn has the highest variance possible under the constraint that it is orthogonal to the preceding components.

Plotting the samples in this transformed system show which samples are more similar.

Here we scaled and centered the normalized data and then performed PCA to look at how the samples cluster. The samples don’t cluster clearly along components 1-4 by condition, which indicates the samples are more variable than the signal between the pCR/non-pCR samples, if the signal exists.


```{r echo=FALSE}
pca_loadings = function(object, ntop = 500) {
    object = as.matrix(object)
    rv <- matrixStats::rowVars(object)
    select <- order(rv, decreasing = TRUE)[seq_len(min(ntop, length(rv)))]
    pca <- prcomp(t(object[select, ]))
    percentVar <- pca$sdev^2/sum(pca$sdev^2)
    names(percentVar) = colnames(pca$x)
    pca$percentVar = percentVar
    return(pca)
}
pcdata = scale(ncounts, center = TRUE, scale = TRUE)
pc = pca_loadings(pcdata, 50)
comps = data.frame(pc$x)
comps$Name = rownames(comps)
library(dplyr)
loadpkg("rgl")
comps = comps %>% left_join(metadata, by = c(Name = "Sample.name"))
pca_plot = function(comps, nc1, nc2, colorby) {
    c1str = paste0("PC", nc1)
    c2str = paste0("PC", nc2)
    ggplot(comps, aes_string(c1str, c2str, color = colorby)) + geom_point() + 
        theme_bw() + xlab(paste0(c1str, ": ", round(pc$percentVar[nc1] * 100), 
        "% variance")) + ylab(paste0(c2str, ": ", round(pc$percentVar[nc2] * 
        100), "% variance")) + theme(aspect.ratio=1)
}



## VAriance explained by components
# ggplot(data.frame(component=reorder(names(pc$percentVar), -pc$percentVar),
#                   percent_var=pc$percentVar),
#        aes(component, percent_var)) + geom_bar(stat='identity') +
#   ylab("percent of total variation") + xlab("") + theme_bw()

pca_plot(comps, 1, 2, "key2")

```


```{r echo=FALSE}
pca_plot(comps, 1, 3, "key2")
```


The following chunk makes a 3D PCA plot of the first three components. We can see that there is some clustering of the samples by pCR along the components 1 and 3.

```{r echo=TRUE, eval=F}
colorbykey2 <- function(k){
        if(k==0){return("red")}
        if(k==1){return("blue")}
}
comps$color = sapply(comps$key2, colorbykey2)
pca_plot3D = function(comps) {
        
    plot3d(comps$PC1, comps$PC2, comps$PC3, type="s",  size=0.75, lit=FALSE, xlab="", ylab="", zlab="", col = comps$color)
        mtext3d(paste0("PC1: ", round(pc$percentVar[1] * 100), "% variance"),       edge="x--", line=2)
        mtext3d(paste0("PC2: ", round(pc$percentVar[2] * 100), "% variance"), edge="y+-", line=3)
        mtext3d(paste0("PC3: ", round(pc$percentVar[3] * 100), "% variance"),          edge="z--", line=3)
    # + geom_point() + 
    #     theme_bw() + xlab(paste0(c1str, ": ", round(pc$percentVar[nc1] * 100), 
    #     "% variance")) + ylab(paste0(c2str, ": ", round(pc$percentVar[nc2] * 
    #     100), "% variance"))
}

pca_plot3D(comps=comps)
```


#### DEA
DEA by the DESeq2 library. The ncounts matrix is converted to integers for the analysis. The original counts are preserved in counts(dds). 

See [this thread](https://www.biostars.org/p/101727/) for log2FC.
```{r echo=FALSE, warning=F, message=F}
source("../../bin/coreDEA_3.R")
design = ~ key2
dea.o <- getDE(ncounts = round(ncounts), metadata = metadata, design = design)
write_csv(dea.o, "preNAC-DEA.csv")
dea.p <- dea.o %>% dplyr::filter(padj <0.05) %>% arrange(-log2FoldChange)
dea.p
```

We see the `r nrow(dea.p) genes sorted by log2FC with significantly altered expression associated with pCR. We can show the results of the differential expression analysis as a volcano plot. A volcano plot typically plots some measure of effect on the x-axis (typically the fold change) and the statistical significance on the y-axis (typically the -log10 of the p-value). Genes that are highly dysregulated are farther to the left and right sides, while highly significant changes appear higher on the plot.

```{r message=FALSE, warning=FALSE}
loadpkg("calibrate") # To label the volcano plot
tab = data.frame(logFC = dea.o$log2FoldChange, negLogPval = -log10(dea.o$padj))
tab2 = data.frame(logFC = dea.o$log2FoldChange, negLogPval = -log10(dea.o$padj), Gene=dea.o$gene.name)
lfc = 1
pval = 0.05
par(mar = c(5, 4, 4, 4))
plot(tab, pch = 16, cex = 0.6, xlab = expression(log[2]~fold~change), ylab = expression(-log[10]~pvalue))

#signGenes = (abs(tab$logFC) > lfc & tab$negLogPval > -log10(pval))

points(tab[(abs(tab$logFC) > lfc), ], pch = 16, cex = 0.8, col = "orange") 
points(tab[(tab$negLogPval > -log10(pval)), ], pch = 16, cex = 0.8, col = "green") 
points(tab[(abs(tab$logFC) > lfc & tab$negLogPval > -log10(pval)), ], pch = 16, cex = 0.8, col = "red") 
abline(h = -log10(pval), col = "green3", lty = 2) 
abline(v = c(-lfc, lfc), col = "blue", lty = 2) 
mtext(paste("pval =", pval), side = 4, at = -log10(pval), cex = 0.8, line = 0.5, las = 1) 
mtext(c(paste("-", lfc, "fold"), paste("+", lfc, "fold")), side = 3, at = c(-lfc, lfc), cex = 0.8, line = 0.5)


with(subset(tab2, negLogPval > -log10(pval) & abs(logFC)>1), textxy(logFC, negLogPval, labs=Gene, cex=.4))

```





#### Pathway Analysis

Here we use GSEA to perform pathway analysis on the list of genes. Gene Set Enrichment Analysis focuses on the changes of expression in groups of genes, and by doing so, this method resolves the problem of the undetectable, small changes in the expression of single genes [see wikipedia.](https://en.wikipedia.org/wiki/Gene_set_enrichment_analysis). 


```{r echo=FALSE,message=F,warning=F}
res<- getDE.raw(ncounts = round(ncounts), metadata = metadata, design = design) # the core script for the pathway analysis expects a dataframe with the DEA named res
source("../../bin/coreDEA_4.R")

converted = unlist(lapply(strsplit(res$rowname, "_", fixed = TRUE), "[", 4))
converted = unlist(lapply(strsplit(converted, ".", fixed = TRUE), "[", 1))
converted = paste0("NM_", converted)
res$refseq_mrna = converted

lost.genes = length(res$rowname) - length((res %>% data.frame() %>% left_join(entrez, by = "refseq_mrna") %>% 
        filter(!is.na(entrezgene)) %>% filter(!is.na(log2FoldChange)) %>% filter(!is.na(lfcSE)))$rowname)

gsea_rs = gsea_cp(res, "pCR")

gsea_summary = gsea_rs$summary %>% arrange(pvalue)
gsea_summary = convert_gsea_results(gsea_summary)
write_csv(x = gsea_summary, path = "preNAC_gsea.csv")

# enrichment analysis
# enrich_rs = enrich_cp(res, "pCR")
# enrich_summary = enrich_rs$summary %>% arrange(p.adjust)
# enrich_summary = convert_enriched_ids(enrich_summary,entrezsymbol = entrezsymbol) %>% arrange(p.adjust)
```

We need to first pull out the Refseq IDs from the Nanostring IDs and convert those to Entrez IDs. Not all of the genes have Entrez IDs, however, we lose `r lost.genes` genes through this conversion. Genes are sorted by signal to noise ratio, which are defined as the log2Fold change (the signal) divided by the log2Fold change standard error (the noise).

We don’t find any pathways or ontology terms differentially enriched via GSEA. I sorted the ontology/KEGG pathway terms by p-value and output a table of the results. The core_symbols are the genes that most strongly contributed to the pathway score, so the ones with the highest or lowest enrichment score depending on the direction of enrichment.

We perform a classic enrichment analysis in GO and KEGG for all the genes differentially epressed by NAC.

```{r echo=FALSE, echo=FALSE,message=F, warning=F}

enrich_rs = enrich_cp(res, "NAC", type="all")
enrich_summary = enrich_rs$summary %>% arrange(p.adjust)
enrich_summary = convert_enriched_ids(enrich_summary,entrezsymbol = entrezsymbol) %>% arrange(p.adjust)
write_csv(x = enrich_summary,path = "preNAC_enrichment.csv" )
```


We perform also a classic enrichment analysis for GO and KEGG using the genes substantially over-expressed and under-expressed. We will use a two-fold fold-change cutoff.
```{r, echo=FALSE,message=F, warning=F}

enrichover_rs = enrich_cp(res, "NAC", type="over")
enrichover_summary = enrichover_rs$summary %>% arrange(p.adjust)
enrichover_summary = convert_enriched_ids(enrichover_summary,entrezsymbol = entrezsymbol) %>% arrange(p.adjust)
write_csv(x = enrichover_summary,path = "preNACover_enrichment.csv" )

enrichunder_rs = enrich_cp(res, "NAC", type="under")
enrichunder_summary = enrichunder_rs$summary %>% arrange(p.adjust)
enrichunder_summary = convert_enriched_ids(enrichunder_summary,entrezsymbol = entrezsymbol) %>% arrange(p.adjust)
write_csv(x = enrichunder_summary,path = "preNACunder_enrichment.csv" )
```

Finally we can see the GO BP and KEGG pathways enriched.

GO BP Enrichment in all the significantly expressed genes:
```{r,echo=FALSE}
dotplot(enrich_rs$bp, x="count", showCategory=10, colorBy="qvalue")
```

KEGG enrichment in all significantly expressed genes:
```{r,echo=FALSE}
dotplot(enrich_rs$kg, x="count", showCategory=10, colorBy="qvalue")
```

GO BP Enrichment in over-expressed genes:
```{r,echo=FALSE}
dotplot(enrichover_rs$bp, x="count", showCategory=10, colorBy="qvalue")
```

KEGG enrichment in over-expressed genes:
```{r,echo=FALSE}
dotplot(enrichover_rs$kg, x="count", showCategory=10, colorBy="qvalue")
```

GO BP Enrichment in under-expressed genes:
```{r,echo=FALSE}
dotplot(enrichunder_rs$bp, x="count", showCategory=10, colorBy="qvalue")
```

KEGG enrichment in under-expressed genes:
```{r,echo=FALSE}
dotplot(enrichunder_rs$kg, x="count", showCategory=10, colorBy="qvalue")
```





